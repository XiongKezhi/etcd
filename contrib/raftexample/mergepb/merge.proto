// compile: protoc -I=$GOPATH/src/go.etcd.io/etcd/contrib/raftexample/mergepb -I=$GOPATH/pkg/mod/github.com/gogo/protobuf@v1.3.2 --gogo_out=$GOPATH/src --go-grpc_out=$GOPATH/src merge.proto
syntax = "proto2";
package mergepb;

option go_package = "go.etcd.io/etcd/contrib/raftexample/mergepb";
import "gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;
option (gogoproto.goproto_enum_prefix_all) = false;
option (gogoproto.goproto_unkeyed_all) = false;
option (gogoproto.goproto_unrecognized_all) = false;
option (gogoproto.goproto_sizecache_all) = false;

message Proposal {
  required uint64 Id 			= 1 [(gogoproto.nullable) = false];
  required string Message = 2 [(gogoproto.nullable) = false];
}

enum MergeMessageType {
  MergeNew          = 0;
  MergeSquashLog    = 1;
  MergeRefreshed    = 2;
  MergeTry          = 3;
  MergeRedirect     = 4;
}

message Node {
  required uint64 Id        = 1 [(gogoproto.nullable) = false];
  required string Ip 				= 2 [(gogoproto.nullable) = false];
  required uint32 MergePort	= 3 [(gogoproto.nullable) = false];
  required uint32 RaftPort 	= 4 [(gogoproto.nullable) = false];
}

message Cluster {
  map<uint64, Node> Nodes = 1 [(gogoproto.nullable) = false];
}

message MergeMessage {
  // included in all messages
  required uint64 Id					   = 1 [(gogoproto.nullable) = false]; // id of the merge process
  required MergeMessageType Type = 2 [(gogoproto.nullable) = false];

  // included in MergeNew or MergeTry
  repeated Cluster Clusters   = 3 [(gogoproto.nullable) = false];

  // included in MergeSquashLog
  optional uint64 ClusterIdx  = 4 [(gogoproto.nullable) = false];
  optional uint64 NextIdx     = 5 [(gogoproto.nullable) = false];
  optional bool   LastBatch   = 6 [(gogoproto.nullable) = false];
  repeated bytes  Logs        = 7;
  optional bytes  Snapshot    = 8;

  // included in MergeRefreshed
  optional uint64 NodeId      = 9 [(gogoproto.nullable) = false];

  // included in MergeRedirect
  optional string RedirectIp   = 10 [(gogoproto.nullable) = false];
  optional uint32 RedirectPort = 11 [(gogoproto.nullable) = false];
}

service Merge {
  rpc Try(TryRequest) returns (TryResponse) {}
  rpc GetLogs(LogRequest) returns (LogResponse) {}
  rpc Refresh(RefreshRequest) returns (RefreshResponse) {}
}

message TryRequest {
  required uint64 Id       = 1 [(gogoproto.nullable) = false]; // id of the merge process
  required Cluster Cluster = 2 [(gogoproto.nullable) = false]; // candidate cluster information
}

message TryResponse {
  required uint64 Id = 1 [(gogoproto.nullable) = false]; // id of the ongoing merge id if exists, or the requested id
}

message LogRequest {
  required uint64 Id     = 1 [(gogoproto.nullable) = false]; // id of the merge process
  required uint64 Index  = 2 [(gogoproto.nullable) = false]; // start index of desired logs
  required uint32 KvPort = 3 [(gogoproto.nullable) = false]; // kv port of the requesting server
}

message LogResponse {
  repeated bytes  Logs      = 1; // a batch of logs, each log only contains the data part of a pb.Entry
  optional bytes  Snapshot  = 2; // snapshot of application data
  optional uint64 NextIdx   = 3 [(gogoproto.nullable) = false]; // next index after snapshot
  optional bool   LastBatch = 4 [(gogoproto.nullable) = false]; // true if this is the last batch
}

message RefreshRequest {
  required uint64     RequesterId = 1 [(gogoproto.nullable) = false]; // id of the requester node, debug usage
  map<uint64, string> Peers       = 2 [(gogoproto.nullable) = false]; // nodes of the coordinator cluster
}

message RefreshResponse {}
